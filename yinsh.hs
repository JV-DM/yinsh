import Haste
import Haste.Graphics.Canvas

-- Colors
-- http://www.colourlovers.com/palette/15/tech_light
green = RGB 209 231 81
blue = RGB 38 173 228
white = RGB 255 255 255

-- Dimensions
spacing         = 60 :: Double
markerWidth     = 20 :: Double
ringInnerRadius = 22 :: Double
ringWidth       = 6 :: Double

-- Yinsh Hex Coordinates
type YCoord = (Int, Int)

-- could be generated by generating all triangular lattice points smaller
-- than a certain cutoff (~ 5)
numPoints = [[2..5], [1..7], [1..8], [1..9], [1..10], [2..10], [2..11], [3..11], [4..11], [5..11], [7..10]]

coords :: [YCoord]
coords = concat $ zipWith (\list ya -> map (\x -> (ya, x)) list) numPoints [1..]

points :: [Point]
points = map fromCoord coords

fromCoord :: YCoord -> Point
fromCoord (ya, yb) = (0.5 * sqrt 3 * x',
                      y' - 0.5 * x')
                where x' = spacing * fromIntegral ya
                      y' = spacing * fromIntegral yb

translateC :: YCoord -> Picture () -> Picture ()
translateC = translate . fromCoord

ringP :: Color -> Picture ()
ringP col = do
    setFillColor col
    fill circL
    stroke circL
    setFillColor white
    fill circS
    stroke circS
    crossP ringInnerRadius
        where circL = circle (0, 0) (ringInnerRadius + ringWidth)
              circS = circle (0, 0) ringInnerRadius

markerP :: Color -> Picture ()
markerP col = do
    setFillColor col
    fill circ
    stroke circ
        where circ = circle (0, 0) markerWidth

crossP :: Double -> Picture ()
crossP len = do
    rotate (2*pi/3) l
    rotate (4*pi/3) l
    rotate (6*pi/3) l
        where l = stroke $ line (0, -len) (0, len)

gridP :: Picture ()
gridP = do
    sequence_ $ mapM translate points (crossP (0.5*spacing))
    translateC (3, 4) $ ringP blue
    translateC (4, 9) $ ringP blue
    translateC (8, 7) $ ringP green
    translateC (6, 3) $ ringP green
    translateC (4, 8) $ ringP blue
    translateC (6, 4) $ markerP green
    translateC (6, 5) $ markerP green
    translateC (6, 6) $ markerP blue
    translateC (6, 7) $ markerP green

drawBoard :: Canvas -> IO ()
drawBoard can = render can $ translate (-15, 140) gridP

main :: IO ()
main = do
    Just can <- getCanvasById "canvas"
    drawBoard can

