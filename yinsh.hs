module Main where

import Haste hiding (next)
import Haste.Graphics.Canvas
import Data.List (minimumBy)
import Data.Ord (comparing)
import Data.IORef
import Control.Monad (when, guard)
import Data.Maybe (fromJust)

import qualified Data.Tree.Game_tree.Game_tree as GT
import qualified Data.Tree.Game_tree.Negascout as NS

-- $setup
-- >>> import Data.List (sort, nub)
-- >>> import Test.QuickCheck hiding (vector)
-- >>> let boardCoords = elements coords
-- >>> instance Arbitrary Direction where arbitrary = elements directions

-- | Similar to Enum's succ, but for cyclic data structures.
-- Wraps around to the beginning when it reaches the 'last' element.
next :: (Eq a, Enum a, Bounded a) => a -> a
next x | x == maxBound = minBound
       | otherwise     = succ x

-- Color theme
-- http://www.colourlovers.com/palette/15/tech_light
green  = RGB  209 231  81
blue   = RGB   38 173 228
white  = RGB  255 255 255
hl     = RGBA 255   0   0 0.5

-- Dimensions
spacing         = 60 :: Double
markerWidth     = 20 :: Double
ringInnerRadius = 22 :: Double
ringWidth       = 6 :: Double
originX         = -15 :: Double
originY         = 495 :: Double

-- Game behaviour
ringsForWin = 1

-- | Yinsh hex coordinates
type YCoord = (Int, Int)

data Direction = N | NE | SE | S | SW | NW
                 deriving (Eq, Enum, Bounded, Show)

-- | All directions
directions :: [Direction]
directions = [minBound .. maxBound]

-- | Opposite direction
--
-- prop> (opposite . opposite) d == d
opposite :: Direction -> Direction
opposite = next . next . next

-- | Vector to the next point on the board in a given direction
vector :: Direction -> YCoord
vector N  = ( 0,  1)
vector NE = ( 1,  1)
vector SE = ( 1,  0)
vector S  = ( 0, -1)
vector SW = (-1, -1)
vector NW = (-1,  0)

-- | Player types: black & white or blue & green
data Player = B | W
              deriving (Eq, Enum, Bounded, Show)

-- | Translate hex coordinates to screen coordinates
screenPoint :: YCoord -> Point
screenPoint (ya, yb) = (0.5 * sqrt 3 * x' + originX, - y' + 0.5 * x' + originY)
    where x' = spacing * fromIntegral ya
          y' = spacing * fromIntegral yb

-- could be generated by generating all triangular lattice points smaller
-- than a certain cutoff (~ 5)
numPoints :: [[Int]]
numPoints = [[2..5], [1..7], [1..8], [1..9],
             [1..10], [2..10], [2..11], [3..11],
             [4..11], [5..11], [7..10]]

-- | All points on the board
--
-- >>> length coords
-- 85
--
coords :: [YCoord]
coords = concat $ zipWith (\list ya -> map (\x -> (ya, x)) list) numPoints [1..]

-- | Check if two points are connected by a line
--
-- >>> connected (3, 4) (8, 4)
-- True
--
-- prop> connected c1 c2 == connected c2 c1
--
connected :: YCoord -> YCoord -> Bool
connected (x, y) (a, b) =        x == a
                          ||     y == b
                          || x - y == a - b

-- | List of points reachable from a certain point
--
-- Every point should be reachable within two moves
-- prop> forAll boardCoords (\c -> sort coords == sort (nub (reachable c >>= reachable)))
--
reachable :: YCoord -> [YCoord]
reachable c = filter (connected c) coords

-- | Vectorially add two coords
add :: YCoord -> YCoord -> YCoord
add (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

-- | Vectorially subtract two coords
sub :: YCoord -> YCoord -> YCoord
sub (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)

-- | Scalar product
prod :: YCoord -> YCoord -> Int
prod (x1, y1) (x2, y2) = x1 * x2 + y1 * y2

-- | Square norm
norm2 :: YCoord -> Int
norm2 (x, y) = x * x + y * y

-- | Get all valid ring moves starting from a given point
validRingMoves :: Board -> YCoord -> [YCoord]
validRingMoves b start = filter (freeCoord b) $ concatMap (validInDir False start) directions
    where markerPos = [ c | Marker _ c <- b ]
          ringPos   = [ c | Ring _ c <- b ]
          validInDir :: Bool -> YCoord -> Direction -> [YCoord]
          validInDir jumped c d = c : rest
              where nextPoint = c `add` vector d
                    rest = if nextPoint `elem` coords && nextPoint `notElem` ringPos
                           then if nextPoint `elem` markerPos
                                then validInDir True nextPoint d
                                else if jumped
                                     then [nextPoint]
                                     else validInDir False nextPoint d
                           else []

-- | Get all nearest neighbors
--
-- Every point has neighbors
--
-- >>> sort coords == sort (nub (coords >>= neighbors))
-- True
--
-- Every point is a neighbor of its neighbor
-- prop> forAll boardCoords (\c -> c `elem` (neighbors c >>= neighbors))
--
neighbors :: YCoord -> [YCoord]
neighbors c = filter (`elem` coords) adj
    where adj = mapM (add . vector) directions c

-- | Get the coordinates of a players markers
markerCoords :: Board -> Player -> [YCoord]
markerCoords b p = [ c | Marker p' c <- b, p == p' ]

-- | Get the coordinates of a players rings
ringCoords :: Board -> Player -> [YCoord]
ringCoords b p = [ c | Ring p' c <- b, p == p' ]

-- | Check if a certain point on the board is free
freeCoord :: Board -> YCoord -> Bool
freeCoord b c = c `notElem` occupied
    where occupied = [ o | Ring _ o <- b ] ++ [ o | Marker _ o <- b ]

-- | Check if a coordinate is one of five in a row
--
-- prop> partOfRun (take 5 $ adjacent c d) c == True
partOfRun :: [YCoord] -> YCoord -> Bool
partOfRun markers start = any (partOfRunD markers start) [NW, N, NE]

partOfRunD :: [YCoord] -> YCoord -> Direction -> Bool
partOfRunD markers start dir = length (runCoordsD markers start dir) == 5

-- | Return the coordinates of the markers making up a run
runCoords :: [YCoord] -> YCoord -> [YCoord]
runCoords markers start = if null cs then [] else head cs
    where cs = filter ((== 5) . length) $ map (runCoordsD markers start) [NW, N, NE]

-- | Combine two lists by taking elements alternatingly. If one list is longer,
-- append the rest.
--
-- prop> zipAlternate [] l == l
-- prop> zipAlternate l [] == l
-- prop> zipAlternate l l  == (l >>= (\x -> [x, x]))
zipAlternate :: [a] -> [a] -> [a]
zipAlternate []     ys = ys
zipAlternate (x:xs) ys = x : zipAlternate ys xs

-- | Get adjacent coordinates in a given direction which could belong to a run.
--
-- prop> runCoordsD (take 7 $ adjacent c d) c d == (take 5 $ adjacent c d)
runCoordsD :: [YCoord] -> YCoord -> Direction -> [YCoord]
runCoordsD markers start dir = if start `elem` markers
                               then take 5 $ zipAlternate right left
                               else []
    where right = takeAvailable dir
          left  = tail $ takeAvailable (opposite dir)  -- use tail to avoid taking the start twice
          takeAvailable d = takeWhile (`elem` markers) $ adjacent start d

-- | Get the adjacent (including start) coordinates in a given direction
adjacent :: YCoord -> Direction -> [YCoord]
adjacent start dir = iterate (`add` vector dir) start

--- AI stuff ---

-- | Possible new game states. The input and output game states are guaranteed
-- to be in turn mode AddRing, AddMarker or RemoveRun.
gamestates :: GameState -> [GameState]
gamestates gs = case turnMode gs of
                    AddRing -> freeCoords >>= newGS gs
                    AddMarker -> ringCoords' >>= newGS gs
                    RemoveRun -> runCoords' >>= newGS gs
                    (MoveRing _) -> error "This is not supposed to happen"
                    RemoveRing -> error "This is not supposed to happen"
    where freeCoords = filter (freeCoord (board gs)) coords
          ringCoords' = ringCoords (board gs) (activePlayer gs)
          runCoords' = filter (partOfRun (markerCoords (board gs) (activePlayer gs))) coords -- TODO: we introduce an artificial branching here since we are generating too many moves (5 for a single run)
          newGS gs' c = case turnMode nextGS of
                            AddRing -> [nextGS]
                            AddMarker -> [nextGS]
                            RemoveRun -> [nextGS]
                            (MoveRing start) -> validRingMoves (board nextGS) start >>= newGS nextGS
                            RemoveRing -> ringCoords (board gs') (activePlayer nextGS) >>= newGS nextGS
                        where nextGS = fromJust $ newGameState gs' c

-- | Heuristic evaluation function for a game state. Everything is calulated
-- from the perspective of the AI player (white). The 'sign' factor is used
-- for the negamax algorithm (Yinsh is a zero sum game).
heuristicValue :: GameState -> Int
heuristicValue gs = sign * valueForWhite
    where sign | activePlayer gs == W = 1
               | otherwise            = -1
          valueForWhite =   valueRings W - valueRings B
                          + valueMarkers W - valueMarkers B
          valueRings p = if rings p == ringsForWin then 10000 else 1
          rings p = if p == W then ringsW gs else ringsB gs
          valueMarkers _ = 1

terminalState :: GameState -> Bool
terminalState gs = ringsB gs == ringsForWin || ringsW gs == ringsForWin

instance GT.Game_tree GameState where
    is_terminal = terminalState
    node_value = heuristicValue
    children = gamestates

--- I/O stuff ---

data DisplayState = BoardOnly GameState -- TODO: do we need this state?
                  | WaitTurn GameState

data Element = Ring Player YCoord
             | Marker Player YCoord
             deriving Eq

data TurnMode = AddRing
              | AddMarker
              | MoveRing YCoord
              | RemoveRun
              | RemoveRing

type Board = [Element]

data GameState = GameState
    { activePlayer :: Player
    , turnMode :: TurnMode
    , board :: Board
    , ringsB :: Int
    , ringsW :: Int
    }

-- | All grid points as screen coordinates
points :: [Point]
points = map screenPoint coords

-- | Translate by hex coordinate
translateC :: YCoord -> Picture () -> Picture ()
translateC = translate . screenPoint

playerColor :: Player -> Color
playerColor B = blue
playerColor W = green

setPlayerColor :: Player -> Picture ()
setPlayerColor = setFillColor . playerColor

pRing :: Player -> Picture ()
pRing p = do
    setPlayerColor p
    fill circL
    stroke circL
    setFillColor white
    fill circS
    stroke circS
    pCross ringInnerRadius
        where circL = circle (0, 0) (ringInnerRadius + ringWidth)
              circS = circle (0, 0) ringInnerRadius

pMarker :: Player -> Picture ()
pMarker p = do
    setPlayerColor p
    fill circ
    stroke circ
        where circ = circle (0, 0) markerWidth

pElement :: Element -> Picture ()
pElement (Ring p c)   = translateC c $ pRing p
pElement (Marker p c) = translateC c $ pMarker p

pCross :: Double -> Picture ()
pCross len = do
    l
    rotate (2 * pi / 3) l
    rotate (4 * pi / 3) l
        where l = stroke $ line (0, -len) (0, len)

pHighlightRing :: Picture ()
pHighlightRing = fill $ circle (0, 0) (markerWidth + 2)

pHighlight :: Board -> Player -> Picture ()
pHighlight b p = do
    let mc  = markerCoords b p
    let mcH = filter (partOfRun mc) mc
    mapM_ (`translateC` pHighlightRing) mcH

pDot :: Picture ()
pDot = do
    setFillColor $ RGB 0 0 0
    fill $ circle (0, 0) 5

pBoard :: Board -> Picture ()
pBoard b = do
    -- Draw grid
    sequence_ $ mapM translate points (pCross (0.5 * spacing))

    -- Draw thick borders for markers which are part of a run
    mapM_ (pHighlight b) [B, W]

    -- Draw markers
    mapM_ pElement b

    -- sequence_ $ mapM (translate . screenPoint) (reachable (3, 6)) pDot
    -- Testing
    -- mapM_ (`translateC` pDot) $ fiveAdjacent (6, 6) NW

pAction :: Board -> TurnMode -> YCoord -> Player -> Picture ()
pAction b AddMarker mc p        = when (mc `elem` ringCoords b p) $ pElement (Marker p mc)
pAction b AddRing mc p          = when (freeCoord b mc) $ pElement (Ring p mc)
pAction b (MoveRing start) mc p = do
    let allowed = validRingMoves b start
    mapM_ (`translateC` pDot) allowed
    when (mc `elem` allowed) $ pElement (Ring p mc)
pAction b RemoveRun mc p        = do
    let runC = runCoords (markerCoords b p) mc
    setFillColor hl
    mapM_ (`translateC` pHighlightRing) runC
pAction _ RemoveRing _ _        = return ()

-- | Render everything that is seen on the screen
pDisplay :: DisplayState
         -> YCoord         -- ^ Coordinate close to mouse cursor
         -> Picture ()
pDisplay (BoardOnly gs) _ = pBoard (board gs)
pDisplay (WaitTurn gs) mc = do
    pBoard (board gs)
    pAction (board gs) (turnMode gs) mc (activePlayer gs)

-- | Get the board coordinate which is closest to the given screen
-- coordinate point
--
-- prop> closestCoord p == (closestCoord . screenPoint . closestCoord) p
closestCoord :: Point -> YCoord
closestCoord (x, y) = coords !! snd lsort
    where lind = zipWith (\p i -> (dist p, i)) points [0..]
          lsort = minimumBy (comparing fst) lind
          dist (x', y') = (x - x')^2 + (y - y')^2

testBoard :: Board
testBoard = [ Ring B (3, 4)
            , Ring B (4, 9)
            , Ring B (7, 9)
            , Ring B (8, 9)
            , Ring B (7, 10)
            , Ring W (8, 7)
            , Ring W (6, 3)
            , Ring W (4, 8)
            , Ring W (4, 2)
            , Ring W (2, 5)
            , Marker W (6, 4)
            , Marker W (6, 5)
            , Marker W (6, 7)
            , Marker W (5, 5)
            , Marker W (4, 5)
            , Marker W (3, 5)
            , Marker B (6, 6)]

testGameState = GameState { activePlayer = B
                          , turnMode = AddMarker
                          , board = testBoard
                          , ringsW = 0
                          , ringsB = 0
                          }

testDisplayState = WaitTurn testGameState

initialGameState = GameState { activePlayer = B
                             , turnMode = AddRing
                             , board = []
                             , ringsW = 0
                             , ringsB = 0
                             }

initialDisplayState = WaitTurn initialGameState

renderCanvas :: Canvas -> DisplayState -> (Int, Int) -> IO ()
renderCanvas can ds point = render can $ pDisplay ds (coordFromXY point)

coordFromXY :: (Int, Int) -> YCoord
coordFromXY (x, y) = closestCoord (fromIntegral x, fromIntegral y)

-- | Check if third point is on a line between the first two
--
-- prop> let shift = add (vector d) in between c (shift (shift c)) (shift c)
-- prop> let shift = add (vector d) in not $ between c (shift c) (shift (shift c))
between :: YCoord -> YCoord -> YCoord -> Bool
between a b c = n2x * n2y == (x `prod` y)^2 && n2y < n2x && n2z < n2x
    where x = b `sub` a
          y = c `sub` a
          z = c `sub` b
          n2x = norm2 x
          n2y = norm2 y
          n2z = norm2 z

-- | Flip all markers between two given coordinates
flippedMarkers :: Board -> YCoord -> YCoord -> Board
flippedMarkers b s e = map flipE b
    where flipE (Marker p c) = Marker (newCol p c) c
          flipE el           = el
          newCol p c = if between s e c
                       then next p
                       else p

-- | Get new game state after 'interacting' at a certain coordinate.
newGameState :: GameState -> YCoord -> Maybe GameState
newGameState gs cc =
    case turnMode gs of
        AddRing -> do
            guard (freeCoord board' cc)
            Just gs { activePlayer = nextPlayer
                    , turnMode = if numRings < 9 then AddRing else AddMarker
                    , board = Ring activePlayer' cc : board'
                    }
            where numRings = length [ 0 | Ring _ _ <- board' ]
        AddMarker -> do
            guard (cc `elem` ringCoords board' activePlayer')
            Just gs { turnMode = MoveRing cc
                    , board = Marker activePlayer' cc : removeRing board'
                    }
        (MoveRing start) -> do
            guard (cc `elem` validRingMoves board' start)
            Just gs { activePlayer = nextPlayer'
                    , turnMode = nextTurnMode
                    , board = Ring activePlayer' cc : flippedBoard
                    }
            where hasRun = any (partOfRun playerMarkers') playerMarkers'
                  nextTurnMode = if hasRun then RemoveRun else AddMarker -- TODO: other player could have 5
                  nextPlayer' =  if hasRun then activePlayer' else nextPlayer
                  flippedBoard = flippedMarkers board' start cc
                  playerMarkers' = markerCoords flippedBoard activePlayer'
        RemoveRun -> do
            guard (partOfRun playerMarkers cc)
            Just gs { turnMode = RemoveRing
                    , board = removeRun board'
                    }
        RemoveRing -> do
            guard (cc `elem` ringCoords board' activePlayer')
            Just gs { activePlayer = nextPlayer
                    , turnMode = AddMarker -- TODO: other player could also have 5
                    , board = removeRing board'
                    , ringsB = if activePlayer' == B then (ringsB gs) + 1 else (ringsB gs)
                    , ringsW = if activePlayer' == W then (ringsW gs) + 1 else (ringsW gs)
                    }
    where activePlayer' = activePlayer gs
          nextPlayer    = next activePlayer'
          removeRing    = filter (/= Ring activePlayer' cc)
          removeRun     = filter (`notElem` map (Marker activePlayer') (runCoords playerMarkers cc))
          board'        = board gs
          playerMarkers = markerCoords board' activePlayer'

newDisplayState :: DisplayState  -- ^ old state
                -> YCoord        -- ^ clicked coordinate
                -> DisplayState  -- ^ new state
newDisplayState (WaitTurn gs) cc = WaitTurn $ case mgs of
                                       Just gs' -> gs'
                                       Nothing -> gs
    where mgs = (newGameState gs cc)
newDisplayState (BoardOnly gs) _ = BoardOnly gs

main :: IO ()
main = do
    Just can <- getCanvasById "canvas"
    Just ce  <- elemById "canvas"

    -- ioDS <- newIORef initialDisplayState
    ioDS <- newIORef testDisplayState

    -- draw initial board
    render can (pBoard [])

    ce `onEvent` OnMouseMove $ \point -> do
        ds <- readIORef ioDS
        renderCanvas can ds point

    ce `onEvent` OnClick $ \_ point -> do
        old <- readIORef ioDS
        let newDS = newDisplayState old (coordFromXY point)
        renderCanvas can newDS point

        let WaitTurn gs = newDS
        if activePlayer gs == W
        then do
            -- AI move
            putStrLn "AI move"
            let plies = 3
            let pv = fst $ NS.alpha_beta_search gs plies
            putStrLn $ "Length of pv: " ++ show (length pv)
            let gs' = pv !! 1
            let newDS' = WaitTurn gs'
            renderCanvas can newDS' point
            writeIORef ioDS newDS'
        else
            writeIORef ioDS newDS
    return ()
