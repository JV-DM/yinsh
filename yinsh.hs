import Haste
import Haste.Graphics.Canvas
import Data.List (minimumBy)

-- >>> import Test.QuickCheck

-- Color theme
-- http://www.colourlovers.com/palette/15/tech_light
green = RGB 209 231  81
blue  = RGB  38 173 228
white = RGB 255 255 255

-- Dimensions
spacing         = 60 :: Double
markerWidth     = 20 :: Double
ringInnerRadius = 22 :: Double
ringWidth       = 6 :: Double
originX         = -15 :: Double
originY         = 140 :: Double

-- | Yinsh hex coordinates
type YCoord = (Int, Int)

-- | Player types: black & white or blue & green
data Player = B | W

-- | Translate hex coordinates to screen coordinates
fromCoord :: YCoord -> Point
fromCoord (ya, yb) = (0.5 * sqrt 3 * x' + originX,
                      y' - 0.5 * x' + originY)
                where x' = spacing * fromIntegral ya
                      y' = spacing * fromIntegral yb

-- could be generated by generating all triangular lattice points smaller
-- than a certain cutoff (~ 5)
numPoints :: [[Int]]
numPoints = [[2..5], [1..7], [1..8], [1..9],
             [1..10], [2..10], [2..11], [3..11],
             [4..11], [5..11], [7..10]]

-- | All points on the pBoard
-- >>> length coords
-- 85
coords :: [YCoord]
coords = concat $ zipWith (\list ya -> map (\x -> (ya, x)) list) numPoints [1..]

-- | Check if two points are connected by a line
-- >>> connected (3, 4) (8, 4)
-- True
--
-- prop> ((\c1 c2 -> connected c1 c2 == connected c2 c1) :: YCoord -> YCoord -> Bool)
--
connected :: YCoord -> YCoord -> Bool
connected (x, y) (a, b) =        x == a
                          ||     y == b
                          || x - y == a - b

-- | List of points reachable from a certain point
reachable :: YCoord -> [YCoord]
reachable c = filter (connected c) coords

data DisplayState = BoardOnly
                  | WaitTurn TurnMode

data Element = Ring Player YCoord
             | Marker Player YCoord

data TurnMode = AddRing Player
              | AddMarker Player
              | MoveRing Player YCoord
              | RemoveRing Player

data GameState = GameState {
                             activePlayer :: Player,
                             turnMode :: TurnMode,
                             board :: [Element]
                           }

-- | All grid points as screen coordinates
points :: [Point]
points = map fromCoord coords

-- | Translate by hex coordinate
translateC :: YCoord -> Picture () -> Picture ()
translateC = translate . fromCoord

playerColor :: Player -> Color
playerColor B = blue
playerColor W = green

pRing :: Player -> Picture ()
pRing p = do
    setFillColor $ playerColor p
    fill circL
    stroke circL
    setFillColor white
    fill circS
    stroke circS
    pCross ringInnerRadius
        where circL = circle (0, 0) (ringInnerRadius + ringWidth)
              circS = circle (0, 0) ringInnerRadius

pMarker :: Player -> Picture ()
pMarker p = do
    setFillColor $ playerColor p
    fill circ
    stroke circ
        where circ = circle (0, 0) markerWidth

pCross :: Double -> Picture ()
pCross len = do
    l
    rotate (2 * pi / 3) l
    rotate (4 * pi / 3) l
        where l = stroke $ line (0, -len) (0, len)

pDot :: Picture ()
pDot = do
    setFillColor $ RGB 0 0 0
    fill $ circle (0, 0) 5

pBoard :: Picture ()
pBoard = do
    sequence_ $ mapM translate points (pCross (0.5 * spacing))
    -- sequence_ $ mapM (translate . fromCoord) (reachable (3, 6)) pDot
    translateC (3, 4) $ pRing B
    translateC (4, 9) $ pRing B
    translateC (8, 7) $ pRing W
    translateC (6, 3) $ pRing W
    translateC (4, 8) $ pRing B
    translateC (6, 4) $ pMarker W
    translateC (6, 5) $ pMarker W
    translateC (6, 7) $ pMarker W
    translateC (6, 6) $ pMarker B

-- | Render everything that is seen on the screen
-- Second argument is the coordinate where the mouse is
pDisplay :: DisplayState -> YCoord -> Picture ()
pDisplay BoardOnly _ = pBoard
-- pDisplay ConnectedPoints c = do
--     pBoard
--     sequence_ $ mapM (translate . fromCoord) (reachable c) pDot
pDisplay (WaitTurn (AddMarker p)) c = pBoard >> translateC c (pMarker p)
pDisplay (WaitTurn (AddRing p)) c = pBoard >> translateC c (pRing p)

getClosestCoord :: Point -> YCoord
getClosestCoord (x, y) = coords !! snd lsort
    where lind = zipWith (\p i -> (dist p, i)) points [0..]
          lsort = minimumBy cmpFst lind
          dist (x', y') = (x-x')^2 + (y-y')^2
          cmpFst t1 t2 = compare (fst t1) (fst t2)

showMoves :: Canvas -> (Int, Int) -> IO ()
showMoves can (x, y) =
    render can $ do
        -- pDisplay BoardOnly
        -- pDisplay ConnectedPoints (getClosestCoord (fromIntegral x, fromIntegral y))
        pDisplay (WaitTurn $ AddRing B) (getClosestCoord (fromIntegral x, fromIntegral y))

main :: IO ()
main = do
    Just can <- getCanvasById "canvas"
    render can pBoard -- TODO: needed?
    Just ce <- elemById "canvas"
    ce `onEvent` OnMouseMove $ showMoves can
    return ()
